# assessor
Assessor, as an adaptive Colloquium, generates challenging training samples for training of symbolic regression systems like Boolformer. Assessor plays the crucial role of self-play, as in AlphaZero, yet is tailored to the asymmetry of symbolic regression: ðŸ‘‰ Crafting puzzles is simpler than solving them.

The setup runs like a GAN. Assessor, a transformer, generates Boolean formulas. The formulas are used to train a system, and are labeled easy if the trained system does it, otherwise hard. The Assessor is in turn trained using the labeled formulas to generate more challenging samples.

Currently, the trained system is simulated by a script that labels a formula (in polish normal form) as easy/hard, if after simplification, its depth is less/more than a given threshhold. As assessor learns to generate formulas with more depth, the threshhold is increased. 

Results
After just 330K iterations, after simplification of the formulas generated by Assessor,
52.7% of the formulas have both depth >= 6 and >= 6 variables

<p align="center">
  <img src="assets/histogram.png"  alt="percentage of formulas with depth and number of variables">
</p>
<p align="center">
  <img src="assets/joint_dist.png"  alt="joint distribution with respect to depth and number of variables">
</p>

## Run the model
First, navigate to the folder where you keep your projects and clone this repository to this folder:

```bash
git clone https://github.com/Majdoddin/assessor.git
```
Dependencies:
```bash
pip install ....
```

Then, open the repository folder:

```bash
cd assessor
```

Now, let's just run the trained Assessor. You need a model checkpoint. Download this 300M parameter model I trained using just 300K iterations.

```bash
wget https://huggingface.co/majdoddin/assessor/resolve/main/state-depth-6-2.pt?download=true
```

## run the model
```bash
python3 assessor.py
```
You'll see the generated formulas in PNF following by they simplified form, num of variables and depth:

```
['or', 'and', 'and', 'or', 'and', 'or', 'and', 'or', 'and', 'or', 'and', 'or', 'and', 'x12', 'x4', 'x6', 'x12', 'x3', 'x4', 'x11', 'x5', 'x11', 'x7', 'x10', 'x4', 'x7', 'x10']
depth:12 var_num:8 simpified: x10|(x4&x7&(x10|(x7&(x11|(x5&(x11|(x4&(x3|(x12&(x6|(x12&x4)))))))))))
```

## train the model
You can train from scratch or from a checkpoint.
Download a checkpoint 
Set the variables ```checkpoint, sec_round, min_depth, eval, start, end, logf```, and comment the ```to_test_a_checkpoint``` lines in ```assessor.py```.
